<!doctype html>
<html lang="en-us">
  <head>
    <title>多线程(一) // tiankong44</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.56.3" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://tiankong44.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="多线程(一)"/>
<meta name="twitter:description" content="多线程(一) 什么是线程？什么事进程？
进程：进入运行状态的程序（CPU\内存\硬盘\带宽）
线程：是进程中的一条执行线索。
多线程的优势：
提高CPU，内存，硬盘，带宽等利用率。
多线程的安全隐患：
主要是单一进程中的多线程容易造成数据的不一致问题。【线程安全】问题是多线程带来的最直观
线程的状态：
 新建状态：线程对象被创建后，进入新建状态。 就绪状态：也被称为“可执行状态”。标志是调用了start（）方法，但是调用之后可能并不立即运行，而是等待CPU的调度。 运行状态：线程获取CPU权限进行执行。 阻塞状态：线程因为某种原因放弃CPU使用权，只能暂时停止运行，分为三种：
 等待阻塞：调用wait（）方法，让线程等待某工作的完成。 同步阻塞：获取synchronized同步锁时失败（因为锁被其它线程占用），进入同步阻塞状态。 其他阻塞：通过调用线程的sleep（）或join（）或发出了I/O请求时，线程会进入到阻塞状态。  死亡状态：线程执行完了或者因异常退出了run（）方法，该线程结束生命周期。
  多线程实现方式
Runnable 接口：
是一个接口，该接口中只定义了一个run方法，让类A实现该接口之后，通过new Thread(new A())等方式新建线程。
Thread 类：
这个类本身就实现了Runnable接口，通过继承该类，可以实现多线程。
对比：
继承接口的扩展性更好，如果多个线程都基于同一个Runnable对象建立，它们就会共享Runnable对象上的资源。因此Runnable接口实现多线程这个方案更好。
关于start()方法
start()： 启动一个新线程，新线程会执行run()方法。start()不能被重复调用。 public class MyThread extends Thread{ ​	public MyThread(String name) { ​	super(name); ​	} ​	@Override ​	public void run() { ​	System.out.println(Thread.currentThread().getName()&#43;&quot;在运行中...&quot;); ​	} }  public class Test{ ​	public static void main(String[] args) { ​	MyThread mythread = new MyThread(&quot;mythread&quot;); ​	System."/>

    <meta property="og:title" content="多线程(一)" />
<meta property="og:description" content="多线程(一) 什么是线程？什么事进程？
进程：进入运行状态的程序（CPU\内存\硬盘\带宽）
线程：是进程中的一条执行线索。
多线程的优势：
提高CPU，内存，硬盘，带宽等利用率。
多线程的安全隐患：
主要是单一进程中的多线程容易造成数据的不一致问题。【线程安全】问题是多线程带来的最直观
线程的状态：
 新建状态：线程对象被创建后，进入新建状态。 就绪状态：也被称为“可执行状态”。标志是调用了start（）方法，但是调用之后可能并不立即运行，而是等待CPU的调度。 运行状态：线程获取CPU权限进行执行。 阻塞状态：线程因为某种原因放弃CPU使用权，只能暂时停止运行，分为三种：
 等待阻塞：调用wait（）方法，让线程等待某工作的完成。 同步阻塞：获取synchronized同步锁时失败（因为锁被其它线程占用），进入同步阻塞状态。 其他阻塞：通过调用线程的sleep（）或join（）或发出了I/O请求时，线程会进入到阻塞状态。  死亡状态：线程执行完了或者因异常退出了run（）方法，该线程结束生命周期。
  多线程实现方式
Runnable 接口：
是一个接口，该接口中只定义了一个run方法，让类A实现该接口之后，通过new Thread(new A())等方式新建线程。
Thread 类：
这个类本身就实现了Runnable接口，通过继承该类，可以实现多线程。
对比：
继承接口的扩展性更好，如果多个线程都基于同一个Runnable对象建立，它们就会共享Runnable对象上的资源。因此Runnable接口实现多线程这个方案更好。
关于start()方法
start()： 启动一个新线程，新线程会执行run()方法。start()不能被重复调用。 public class MyThread extends Thread{ ​	public MyThread(String name) { ​	super(name); ​	} ​	@Override ​	public void run() { ​	System.out.println(Thread.currentThread().getName()&#43;&quot;在运行中...&quot;); ​	} }  public class Test{ ​	public static void main(String[] args) { ​	MyThread mythread = new MyThread(&quot;mythread&quot;); ​	System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://tiankong44.github.io/post/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%80/" />
<meta property="article:published_time" content="2019-08-06T20:30:43+08:00" />
<meta property="article:modified_time" content="2019-08-06T18:30:43+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://tiankong44.github.io"><img class="app-header-avatar" src="/avatar.jpg" alt="John Doe" /></a>
      <h1>tiankong44</h1>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vehicula turpis sit amet elit pretium.</p>
      <div class="app-header-social">
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">多线程(一)</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Aug 6, 2019
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div></div>
    </header>
    <div class="post-content">
      

<h4 id="多线程-一">多线程(一)</h4>

<p><strong>什么是线程？什么事进程？</strong></p>

<p>进程：进入运行状态的程序（CPU\内存\硬盘\带宽）</p>

<p>线程：是进程中的一条执行线索。</p>

<p><strong>多线程的优势：</strong></p>

<p>提高CPU，内存，硬盘，带宽等利用率。</p>

<p><strong>多线程的安全隐患：</strong></p>

<p>主要是单一进程中的多线程容易造成数据的不一致问题。【线程安全】问题是多线程带来的最直观</p>

<p><strong>线程的状态：</strong></p>

<ol>
<li>新建状态：线程对象被创建后，进入新建状态。</li>
<li>就绪状态：也被称为“可执行状态”。标志是调用了start（）方法，但是调用之后可能并不立即运行，而是等待CPU的调度。</li>
<li>运行状态：线程获取CPU权限进行执行。</li>

<li><p>阻塞状态：线程因为某种原因放弃CPU使用权，只能暂时停止运行，分为三种：</p>

<ol>
<li>等待阻塞：调用wait（）方法，让线程等待某工作的完成。</li>
<li>同步阻塞：获取synchronized同步锁时失败（因为锁被其它线程占用），进入同步阻塞状态。</li>
<li>其他阻塞：通过调用线程的sleep（）或join（）或发出了I/O请求时，线程会进入到阻塞状态。</li>
</ol></li>

<li><p>死亡状态：线程执行完了或者因异常退出了run（）方法，该线程结束生命周期。</p></li>
</ol>

<p><strong>多线程实现方式</strong></p>

<p>Runnable 接口：</p>

<p>是一个接口，该接口中只定义了一个run方法，让类A实现该接口之后，通过new Thread(new A())等方式新建线程。</p>

<p>Thread 类：</p>

<p>这个类本身就实现了Runnable接口，通过继承该类，可以实现多线程。</p>

<p><strong>对比：</strong></p>

<p>继承接口的扩展性更好，如果多个线程都基于同一个Runnable对象建立，它们就会共享Runnable对象上的资源。因此Runnable接口实现多线程这个方案更好。</p>

<p><strong>关于start()方法</strong></p>

<pre><code>start()：

启动一个新线程，新线程会执行run()方法。start()不能被重复调用。

public class MyThread extends Thread{

​	public MyThread(String name) {

​		super(name);

​	}

​	@Override

​	public void run() {

​		System.out.println(Thread.currentThread().getName()+&quot;在运行中...&quot;);

​	}

}

</code></pre>

<pre><code>public class Test{

​	public static void main(String[] args) {

​		MyThread mythread = new MyThread(&quot;mythread&quot;);

​		System.out.println(Thread.currentThread().getName()+&quot;调用了 mythread.run()&quot;);

​		mythread.run();

​		System.out.println(Thread.currentThread().getName()+&quot;调用了 mythread.start()&quot;);

​		mythread.start();

​	}

}
</code></pre>

<pre><code>这个案例的运行结果如下：

main调用了 mythread.run()

main在运行中...

main调用了 mythread.start()

mythread在运行中...
</code></pre>

<p><strong>要点：</strong></p>

<ol>
<li>Thread类中提供了一个带参构造方法，这个方法可以为name进行赋值，Thread类有一个name属性，这个属性被volatile修饰。</li>
<li>main方法的name是main。</li>
</ol>

<p><strong>关键字 synchronized</strong></p>

<p><strong>原理：</strong></p>

<p>一个对象有且仅有一个同步锁。当调用某对象的synchronized方法时，就获取了该对象的同步锁。不同线程对于同步锁的访问互斥。通俗解释为：synchronized表示一个锁，这个锁表示其中的代码不支持有多个线程同时执行，一旦有一个线程执行了synchronized部分之后，其他线程只能等待它执行完毕，才能有机会获得CPU资源。</p>

<p>语法：</p>

<p>synchronized(obj)：获取obj对象的同步锁</p>

<p><strong>基本规则：</strong></p>

<ol>
<li>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。</li>
<li>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。</li>
<li>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。</li>
</ol>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
